# Operationg System

* [Process vs Thread](#Process-vs-Thread)
* [Multi Process vs Multi Thread](#Multi-Process-vs-Multi-Thread)
* [Thread-Safe](#Thread-Safe)
* [동기화 객체의 종류](#동기화-객체의-종류)



<br>

<br>



# Process vs Thread

### Program?

어떤 작업을 위해 실행할 수 있는 파일

<br>

### Process?

컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램

메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)

운영체제로부터 시스템 자원을 할당받는 작업의 단위

(무엇을 할당받는가? Code, Data, Stack, Heap 구조의 독립된 메모리 영역)

<br>

### Thread?

프로세스 내에서 실행되는 흐름의 단위

프로세스의 특정 수행 경로(프로세스가 할당받는 자원을 이용하는 실행의 단위)

스레드는 하나의 프로세스 안에서 Stack을 제외한 자원을 공유

자원을 공유하기 때문에 Register와 Stack 이외의 Heap 메모리는 서로 읽고 쓸 수 있다.

한 스레드가 프로세스 자원을 변경하면 다른 스레드로 변경된 것을 확인할 수 있다.

<br>

### Java Thread?

자바에는 프로세스가 존재하지 않고 스레드만 존재, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록

자바 스레드 스케줄링은 전적으로 JVM에 의해 이루어지며 스레드와 관련된 많은 정보들도 JVM이 관리(몇 개의 스레드가 존재하는가, 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인가, 스레드의 상태는 어떠한가, 스레드의 우선순위는 무엇인가)



<br>
<br>



# Multi Process vs Multi Thread

### Multi Process?

하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하는 것

| Pros                                                         | Cons                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다. | Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 된다.<br>프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다. |

<br>

### Multi Thread?

하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것
윈도우, 리눅스 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본으로 함
웹 서버: 대표적인 멀티 스레드 응용 프로그램

| Pros                                                         | Cons                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리(자원의 효율설 증대)<br>스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들고 스레드 사이의 작업량이 작아 Context Switching이 빠름(처리 비용 감소)<br>프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하여 통신의 부담이 적음(프로그램 응답 시간 단축) | 주의 깊은 설계가 필요<br>디버깅이 까다로운 디버깅<br>단일 프로세스 시스템의 경우 효과를 기대하기 어려움.<br>다른 프로세스에서 스레드를 제어할 수 없음<br>멀티 스레드의 경우 자원 공유의 문제가 발생(동기화 문제): 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받음 |

<br>

### Multi Process vs Multi ThreadMulti Process 대신 Multi Thread를 사용하는 이유

프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것

#### Why?

* 자원의 효율성 증대
  * 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
  * 프로세스 간의 Context Switching시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐쉬 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 때문
    스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.

* 처리 비용 감소 및 응답 시간 단축
  * 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다.
  * 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문, 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
  * Context Switching시 스레드는 Stack 영역만 처리하기 때문

주의: 동기화 문제. 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.



<br>

<br>



# Thread-Safe

멀티 스레드 프로그래밍에서 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 의미

하나의 함수가 한 스레드로부터 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바로 나오는 것

#### How?

1. Re-entrancy

   어떤 함수가 한 스레드에 의해 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바로 주어져야 한다.

2. Thread-local storage

   공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는다. 이 방식은 동기화 방법과 관련되어 있고, 또한 공유상태를 피할 수 없을 때 사용하는 방식이다.

3. Mutual exclusion

   공유 자원을 꼭 사용해야 할 경우 해당 자원의 접근을 세마포어 등의 락으로 통제한다.

4. Atomic operations

   공유 자원에 접근할 때 원자 연산을 이용하거나 '원자적'으로 정의된 접근 방법을 사용함으로써 상호 배제를 구현할 수 있다.

상호배제: 한 Thread가 자원에 접근할 때 다른 Thread의 접근을 막는 것을 의미한다. 통상적으로 Mutual Exclusion(상호배제) 방식을 이용한 Critical Section 처리가 자주 사용된다.

<br>
<br>



# 동기화 객체의 종류

#### 동기화 객체?

커널에서 제공하는 객체

스레드 사용시 문제되는 자원을 공유할 때 충동에 대한 해법 제시

<br>

#### Critical Section

보호하는 대상은 주로 전역 객체. 메모리와 관련된 대상은 반드시 보호해야 멀티스레드 환경에서 문제가 되지 않는다.

Lock, Unlock을 사용하여 동기화를 유지한다.

<br>

#### Mutex

뮤텍스는 뮤텍스를 소유한 스레드를 기억하고 있음으로써 같은 스레드가 같은 뮤텍스를 중복 호출하더라도 데드락
현상이 발생하기 않는다.

스레드와 프로세스를 동기화 시키는데도 사용(뮤텍스가 동기화를 하는데 드는 비용이 크리티컬 섹션에 비해 큼)

Lock, Unlock을 사용하여 동기화를 유지한다.

Dead-Lock? 스레드간의 서로 특정 자원을 점유한 상태에서 Lock() 함수를 호출하여 다른 스레드의 접근을 차단했지만 내부 코드사에서 조건이 맞지 않아서 Unlock() 함수를 호출하지 못하고 모든 스레드의 흐름이 정지된 상태

<br>

#### Semaphore

한번에 동시 스레드 접근을 허용

클라이언트 측에서 이 객체를 사용할 이유는 적지만 서버측의 경우 동시 접속자 수에 제한을 둘 때 히당 동기화 객체를 사용한다.

<br>

<br>



## 참고자료

Process vs Thread

* https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

Multi Process vs Multi Thread

* https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

Thread Safe

* https://gompangs.tistory.com/entry/OS-Thread-Safe%EB%9E%80

동기화 객체의 종류

* https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=brosvaby&logNo=168498270
